{"contracts": [{"name": "MetaCoin", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "MetaCoin", "author": "Author Here", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [{"name": "addr", "type": "address"}], "name": "getBalanceInEth", "outputs": [{"name": "value", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "receiver", "type": "address"}, {"name": "amount", "type": "uint256"}], "name": "sendCoin", "outputs": [{"name": "sufficient", "type": "bool"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "addr", "type": "address"}], "name": "getBalance", "outputs": [{"name": "value", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"inputs": [], "payable": false, "stateMutability": "nonpayable", "type": "constructor"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "_from", "type": "address"}, {"indexed": true, "name": "_to", "type": "address"}, {"indexed": false, "name": "_value", "type": "uint256"}], "name": "Transfer", "type": "event"}], "userdoc": {"methods": {"getBalance(address)": {"notice": "Returns MetaCoin balance for a given address"}, "getBalanceInEth(address)": {"notice": "Returns equivalent Ether balance for a given address"}, "sendCoin(address,uint256)": {"notice": "Transfer coins from sender to receiver"}}}}, "endpoint": {"address": "0x0000000000000000000000000000000000000000", "networkID": 1, "chainID": 1}, "dev": {"devdoc": {"author": "Author Here", "methods": {"getBalance(address)": {"return": "{ \"value\" : \"Token balance of account\" }"}, "getBalanceInEth(address)": {"details": "Uses the `ConvertLib.sol` library for conversions", "return": "{ \"value\" : \"Ether equivalent balance of account\" }"}, "sendCoin(address,uint256)": {"details": "This is just a simple example of a coin-like contract. It is not standards compatible and cannot be expected to talk to other coin/token contracts. If you want to create a standards-compliant token, see: [ConsenSys/Tokens](https://github.com/ConsenSys/Tokens). Cheers!", "return": "{ \"sufficient\": \"Transfer is succesful\" }"}}, "title": "MetaCoin Interface"}, "sources": {"keccak256": "0xf583c580ac981029f63ec3e39bd97b6955eb91241d6f066897268c12e3412b98", "swarm_URL": "bzzr://d9a33154f48e2d75ec875dcaeff392fce12866a45855d04a3e4d0aaa7af9fe5b"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.2;\n\nimport \"./ConvertLib.sol\";\n\n/**\n@title MetaCoin Interface\n@author Author Here\n@dev TODO update solidity compiler to add user/dev notes\n*/\ncontract MetaCoin {\n\n\t// TODO update solidity compiler to support variable definitions\n\tmapping (address => uint) balances;\n\n\t// TODO update solidity compiler to support events\n\tevent Transfer(address indexed _from, address indexed _to, uint256 _value);\n\n\t// TODO update solidity compiler to support constructor\n\tfunction MetaCoin() {\n\t\tbalances[tx.origin] = 10000;\n\t}\n\n\t/**\n\t@notice Transfer coins from sender to receiver\n\t@dev\n\t\tThis is just a simple example of a coin-like contract.\n\t\tIt is not standards compatible and cannot be expected to talk to other\n\t\tcoin/token contracts. If you want to create a standards-compliant\n\t\ttoken, see: [ConsenSys/Tokens](https://github.com/ConsenSys/Tokens). Cheers!\n\t@param receiver Address of the receipient\n\t@param amount Amount of tokens to send\n\t@return { \"sufficient\": \"Transfer is succesful\" }\n\t*/\n\tfunction sendCoin(address receiver, uint amount) returns (bool sufficient) {\n\t\tif (balances[msg.sender] < amount) return false;\n\t\tbalances[msg.sender] -= amount;\n\t\tbalances[receiver] += amount;\n\t\tTransfer(msg.sender, receiver, amount);\n\t\treturn true;\n\t}\n\n\t/**\n\t@notice Returns equivalent Ether balance for a given address\n\t@dev Uses the `ConvertLib.sol` library for conversions\n\t@param addr Queried address\n\t@return { \"value\" : \"Ether equivalent balance of account\" }\n\t*/\n\tfunction getBalanceInEth(address addr) returns(uint value){\n\t\treturn ConvertLib.convert(getBalance(addr),2);\n\t}\n\t/**\n\t@notice Returns MetaCoin balance for a given address\n\t@param addr Queried address\n\t@return { \"value\" : \"Token balance of account\" }\n\t*/\n\tfunction getBalance(address addr) returns(uint value) {\n\t\treturn balances[addr];\n\t}\n}\n"}, {"name": "Set", "contract_type": "library", "JSON": {"contract": {"descriptor": {"name": "Set", "author": "", "language": "Solidity", "contract_type": "library", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [{"name": "self", "type": "Set.Data storage"}, {"name": "value", "type": "uint256"}], "name": "remove", "outputs": [{"name": "", "type": "bool"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [{"name": "self", "type": "Set.Data storage"}, {"name": "value", "type": "uint256"}], "name": "contains", "outputs": [{"name": "", "type": "bool"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [{"name": "self", "type": "Set.Data storage"}, {"name": "value", "type": "uint256"}], "name": "insert", "outputs": [{"name": "", "type": "bool"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}], "userdoc": {"methods": {}}}, "endpoint": {}, "dev": {"devdoc": {"methods": {}}, "sources": {"keccak256": "0xef39e446d16b4f599454fe120cd7345d3c8819c25da421de60e20d9c3efefb11", "swarm_URL": "bzzr://71aa9deb4400e7201428d0715cbc343b778a14f7c50e6272ee4bd1d15a007fa4"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.16;\n\nlibrary Set {\n  // We define a new struct datatype that will be used to\n  // hold its data in the calling contract.\n  struct Data { mapping(uint => bool) flags; }\n\n  // Note that the first parameter is of type \"storage\n  // reference\" and thus only its storage address and not\n  // its contents is passed as part of the call.  This is a\n  // special feature of library functions.  It is idiomatic\n  // to call the first parameter `self`, if the function can\n  // be seen as a method of that object.\n  function insert(Data storage self, uint value)\n      public\n      returns (bool)\n  {\n      if (self.flags[value])\n          return false; // already there\n      self.flags[value] = true;\n      return true;\n  }\n\n  function remove(Data storage self, uint value)\n      public\n      returns (bool)\n  {\n      if (!self.flags[value])\n          return false; // not there\n      self.flags[value] = false;\n      return true;\n  }\n\n  function contains(Data storage self, uint value)\n      public\n      view\n      returns (bool)\n  {\n      return self.flags[value];\n  }\n}\n"}, {"name": "SafeMath", "contract_type": "library", "JSON": {"contract": {"descriptor": {"name": "SafeMath", "author": "", "language": "Solidity", "contract_type": "library", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": true, "inputs": [{"name": "a", "type": "uint256"}, {"name": "b", "type": "uint256"}], "name": "add", "outputs": [{"name": "c", "type": "uint256"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": true, "inputs": [{"name": "a", "type": "uint256"}, {"name": "b", "type": "uint256"}], "name": "div", "outputs": [{"name": "", "type": "uint256"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": true, "inputs": [{"name": "a", "type": "uint256"}, {"name": "b", "type": "uint256"}], "name": "sub", "outputs": [{"name": "", "type": "uint256"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": true, "inputs": [{"name": "a", "type": "uint256"}, {"name": "b", "type": "uint256"}], "name": "mul", "outputs": [{"name": "c", "type": "uint256"}], "payable": false, "stateMutability": "view", "type": "function"}], "userdoc": {"methods": {}}}, "endpoint": {"address": "0x0000000000000000000000000000000000000000", "networkID": 1, "chainID": 1}, "dev": {"devdoc": {"methods": {"add(uint256,uint256)": {"details": "Adds two numbers, throws on overflow."}, "div(uint256,uint256)": {"details": "Integer division of two numbers, truncating the quotient."}, "mul(uint256,uint256)": {"details": "Multiplies two numbers, throws on overflow."}, "sub(uint256,uint256)": {"details": "Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend)."}}, "title": "SafeMath"}, "sources": {"keccak256": "0xf0dd4a95d2666f6333f1b9d8a486f0912e619b29a91ca89c6474051e825c5aa5", "swarm_URL": "bzzr://bf424353d996ad1bea8e225d1ca7d5dacdd62dfc193d3a1d93c6986b82e7f79c"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.23;\n\n\n/**\n * @title SafeMath\n * @dev Math operations with safety checks that throw on error\n */\nlibrary SafeMath {\n\n  /**\n  * @dev Multiplies two numbers, throws on overflow.\n  */\n  function mul(uint256 a, uint256 b) constant returns (uint256 c) {\n    // Gas optimization: this is cheaper than asserting 'a' not being zero, but the\n    // benefit is lost if 'b' is also tested.\n    // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522\n    if (a == 0) {\n      return 0;\n    }\n\n    c = a * b;\n    assert(c / a == b);\n    return c;\n  }\n\n  /**\n  * @dev Integer division of two numbers, truncating the quotient.\n  */\n  function div(uint256 a, uint256 b) constant returns (uint256) {\n    // assert(b > 0); // Solidity automatically throws when dividing by 0\n    // uint256 c = a / b;\n    // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n    return a / b;\n  }\n\n  /**\n  * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend).\n  */\n  function sub(uint256 a, uint256 b) constant returns (uint256) {\n    assert(b <= a);\n    return a - b;\n  }\n\n  /**\n  * @dev Adds two numbers, throws on overflow.\n  */\n  function add(uint256 a, uint256 b) constant returns (uint256 c) {\n    c = a + b;\n    assert(c >= a);\n    return c;\n  }\n}\n"}, {"name": "Claimable", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "Claimable", "author": "", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [], "name": "claimOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "renounceOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [], "name": "owner", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": true, "inputs": [], "name": "pendingOwner", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [{"name": "newOwner", "type": "address"}], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}], "name": "OwnershipRenounced", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}, {"indexed": true, "name": "newOwner", "type": "address"}], "name": "OwnershipTransferred", "type": "event"}], "userdoc": {"methods": {"renounceOwnership()": {"notice": "Renouncing to ownership will leave the contract without an owner. It will not be possible to call the functions with the `onlyOwner` modifier anymore."}}}}, "endpoint": {}, "dev": {"devdoc": {"methods": {"claimOwnership()": {"details": "Allows the pendingOwner address to finalize the transfer."}, "renounceOwnership()": {"details": "Allows the current owner to relinquish control of the contract."}, "transferOwnership(address)": {"details": "Allows the current owner to set the pendingOwner address."}}, "title": "Claimable"}, "sources": {"keccak256": "0xbee545b3c31874580e790f0cb74865fd2bb28086d08d17c7f50857eddf072c77", "swarm_URL": "bzzr://98f1c4b8de8be45b42d29c1f35bcb89fbe8116ae6f269f488e6c4e5ce9f24d1c"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.23;\n\n\nimport \"./Ownable.sol\";\n\n\n/**\n * @title Claimable\n * @dev Extension for the Ownable contract, where the ownership needs to be claimed.\n * This allows the new owner to accept the transfer.\n */\ncontract Claimable is Ownable {\n  address public pendingOwner;\n\n  /**\n   * @dev Modifier throws if called by any account other than the pendingOwner.\n   */\n  modifier onlyPendingOwner() {\n    require(msg.sender == pendingOwner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to set the pendingOwner address.\n   * @param newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address newOwner) onlyOwner public {\n    pendingOwner = newOwner;\n  }\n\n  /**\n   * @dev Allows the pendingOwner address to finalize the transfer.\n   */\n  function claimOwnership() onlyPendingOwner public {\n    emit OwnershipTransferred(owner, pendingOwner);\n    owner = pendingOwner;\n    pendingOwner = address(0);\n  }\n}\n"}, {"name": "usingOraclize", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "usingOraclize", "author": "", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": true, "inputs": [{"name": "_a", "type": "string"}], "name": "parseInt", "outputs": [{"name": "", "type": "uint256"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": true, "inputs": [{"name": "_haystack", "type": "string"}, {"name": "_needle", "type": "string"}], "name": "indexOf", "outputs": [{"name": "", "type": "int256"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": true, "inputs": [{"name": "_a", "type": "string"}, {"name": "_b", "type": "string"}, {"name": "_c", "type": "string"}, {"name": "_d", "type": "string"}, {"name": "_e", "type": "string"}], "name": "strConcat", "outputs": [{"name": "", "type": "string"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": true, "inputs": [{"name": "_a", "type": "string"}], "name": "parseAddr", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": true, "inputs": [{"name": "_a", "type": "string"}, {"name": "_b", "type": "uint256"}], "name": "parseInt", "outputs": [{"name": "", "type": "uint256"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": true, "inputs": [{"name": "_a", "type": "string"}, {"name": "_b", "type": "string"}], "name": "strCompare", "outputs": [{"name": "", "type": "int256"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": true, "inputs": [{"name": "i", "type": "uint256"}], "name": "uint2str", "outputs": [{"name": "", "type": "string"}], "payable": false, "stateMutability": "view", "type": "function"}], "userdoc": {"methods": {}}}, "endpoint": {}, "dev": {"devdoc": {"methods": {}}, "sources": {"keccak256": "0x0514426085f77a6dfda04581dba51b5b706378cacb476e67c269a7fc5cb77a5b", "swarm_URL": "bzzr://f594d7141e715f654160311ff09dd29a5af087322279a998bcb83b95e2e70b87"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "// <ORACLIZE_API>\n/*\nCopyright (c) 2015-2016 Oraclize SRL\nCopyright (c) 2016 Oraclize LTD\n\n\n\nPermission is hereby granted, free of charge, to any person obtaining a copy\nof this software and associated documentation files (the \"Software\"), to deal\nin the Software without restriction, including without limitation the rights\nto use, copy, modify, merge, publish, distribute, sublicense, and/or sell\ncopies of the Software, and to permit persons to whom the Software is\nfurnished to do so, subject to the following conditions:\n\n\n\nThe above copyright notice and this permission notice shall be included in\nall copies or substantial portions of the Software.\n\n\n\nTHE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\nIMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\nFITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE\nAUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\nLIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\nOUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\nTHE SOFTWARE.\n*/\n\n\n/* SUBSET OF ORACLIZE_API FUNCTIONS */\n\ncontract usingOraclize {\n\n    function parseAddr(string _a) constant returns (address){\n        bytes memory tmp = bytes(_a);\n        uint160 iaddr = 0;\n        uint160 b1;\n        uint160 b2;\n        for (uint i=2; i<2+2*20; i+=2){\n            iaddr *= 256;\n            b1 = uint160(tmp[i]);\n            b2 = uint160(tmp[i+1]);\n            if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87;\n            else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55;\n            else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48;\n            if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87;\n            else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55;\n            else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48;\n            iaddr += (b1*16+b2);\n        }\n        return address(iaddr);\n    }\n\n    function strCompare(string _a, string _b) constant returns (int) {\n        bytes memory a = bytes(_a);\n        bytes memory b = bytes(_b);\n        uint minLength = a.length;\n        if (b.length < minLength) minLength = b.length;\n        for (uint i = 0; i < minLength; i ++)\n            if (a[i] < b[i])\n                return -1;\n            else if (a[i] > b[i])\n                return 1;\n        if (a.length < b.length)\n            return -1;\n        else if (a.length > b.length)\n            return 1;\n        else\n            return 0;\n    }\n\n    function indexOf(string _haystack, string _needle) constant returns (int) {\n        bytes memory h = bytes(_haystack);\n        bytes memory n = bytes(_needle);\n        if(h.length < 1 || n.length < 1 || (n.length > h.length))\n            return -1;\n        else if(h.length > (2**128 -1))\n            return -1;\n        else\n        {\n            uint subindex = 0;\n            for (uint i = 0; i < h.length; i ++)\n            {\n                if (h[i] == n[0])\n                {\n                    subindex = 1;\n                    while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex])\n                    {\n                        subindex++;\n                    }\n                    if(subindex == n.length)\n                        return int(i);\n                }\n            }\n            return -1;\n        }\n    }\n\n    function strConcat(string _a, string _b, string _c, string _d, string _e) constant returns (string) {\n        bytes memory _ba = bytes(_a);\n        bytes memory _bb = bytes(_b);\n        bytes memory _bc = bytes(_c);\n        bytes memory _bd = bytes(_d);\n        bytes memory _be = bytes(_e);\n        string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length);\n        bytes memory babcde = bytes(abcde);\n        uint k = 0;\n        for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i];\n        for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i];\n        for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i];\n        for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i];\n        for (i = 0; i < _be.length; i++) babcde[k++] = _be[i];\n        return string(babcde);\n    }\n\n    // parseInt\n    function parseInt(string _a) constant returns (uint) {\n        return parseInt(_a, 0);\n    }\n\n    // parseInt(parseFloat*10^_b)\n    function parseInt(string _a, uint _b) constant returns (uint) {\n        bytes memory bresult = bytes(_a);\n        uint mint = 0;\n        bool decimals = false;\n        for (uint i=0; i<bresult.length; i++){\n            if ((bresult[i] >= 48)&&(bresult[i] <= 57)){\n                if (decimals){\n                   if (_b == 0) break;\n                    else _b--;\n                }\n                mint *= 10;\n                mint += uint(bresult[i]) - 48;\n            } else if (bresult[i] == 46) decimals = true;\n        }\n        if (_b > 0) mint *= 10**_b;\n        return mint;\n    }\n\n    function uint2str(uint i) constant returns (string){\n        if (i == 0) return \"0\";\n        uint j = i;\n        uint len;\n        while (j != 0){\n            len++;\n            j /= 10;\n        }\n        bytes memory bstr = new bytes(len);\n        uint k = len - 1;\n        while (i != 0){\n            bstr[k--] = byte(48 + i % 10);\n            i /= 10;\n        }\n        return string(bstr);\n    }\n\n}\n// </ORACLIZE_API>\n"}, {"name": "Destructible", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "Destructible", "author": "", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [], "name": "renounceOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "destroy", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [], "name": "owner", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [{"name": "_newOwner", "type": "address"}], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [{"name": "_recipient", "type": "address"}], "name": "destroyAndSend", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"inputs": [], "payable": true, "stateMutability": "payable", "type": "constructor"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}], "name": "OwnershipRenounced", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}, {"indexed": true, "name": "newOwner", "type": "address"}], "name": "OwnershipTransferred", "type": "event"}], "userdoc": {"methods": {"renounceOwnership()": {"notice": "Renouncing to ownership will leave the contract without an owner. It will not be possible to call the functions with the `onlyOwner` modifier anymore."}}}}, "endpoint": {}, "dev": {"devdoc": {"methods": {"destroy()": {"details": "Transfers the current balance to the owner and terminates the contract."}, "renounceOwnership()": {"details": "Allows the current owner to relinquish control of the contract."}, "transferOwnership(address)": {"details": "Allows the current owner to transfer control of the contract to a newOwner."}}, "title": "Destructible"}, "sources": {"keccak256": "0x8993ad0305609605827d7b95764edcc60147ae44d467370cfb43499916b052a3", "swarm_URL": "bzzr://a37b8d8085a4016a9c761cad19e01050595ec8454d1989141a11e7a49f440c56"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.23;\n\n\nimport \"./Ownable.sol\";\n\n\n/**\n * @title Destructible\n * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner.\n */\ncontract Destructible is Ownable {\n\n  constructor() public payable { }\n\n  /**\n   * @dev Transfers the current balance to the owner and terminates the contract.\n   */\n  function destroy() onlyOwner public {\n    selfdestruct(owner);\n  }\n\n  function destroyAndSend(address _recipient) onlyOwner public {\n    selfdestruct(_recipient);\n  }\n}\n"}, {"name": "ConvertLib", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "ConvertLib", "author": "Joe Bloggs", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [{"name": "amount", "type": "uint256"}, {"name": "conversionRate", "type": "uint256"}], "name": "convert", "outputs": [{"name": "convertedAmount", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}], "userdoc": {"methods": {"convert(uint256,uint256)": {"notice": "Converts given value to Ether value"}}}}, "endpoint": {}, "dev": {"devdoc": {"author": "Joe Bloggs", "methods": {"convert(uint256,uint256)": {"return": "{ \"convertedAmount\" : \"Ether equivalent amount\" }"}}, "title": "Convert-o-matic 2000"}, "sources": {"keccak256": "0xf583c580ac981029f63ec3e39bd97b6955eb91241d6f066897268c12e3412b98", "swarm_URL": "bzzr://d9a33154f48e2d75ec875dcaeff392fce12866a45855d04a3e4d0aaa7af9fe5b"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.2;\n\n/**\n@title Convert-o-matic 2000\n@author Joe Bloggs\n*/\nlibrary ConvertLib{\n\t/**\n\t@notice Converts given value to Ether value\n\t@param amount Token amount\n\t@param conversionRate Rate of conversion - Tokens -> Ether\n\t@return { \"convertedAmount\" : \"Ether equivalent amount\" }\n\t*/\n\tfunction convert(uint amount, uint conversionRate) returns (uint convertedAmount)\n\t{\n\t\treturn amount * conversionRate;\n\t}\n}\n"}, {"name": "Pausable", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "Pausable", "author": "", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [], "name": "unpause", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [], "name": "paused", "outputs": [{"name": "", "type": "bool"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [], "name": "renounceOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": false, "inputs": [], "name": "pause", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [], "name": "owner", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [{"name": "_newOwner", "type": "address"}], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"anonymous": false, "inputs": [], "name": "Pause", "type": "event"}, {"anonymous": false, "inputs": [], "name": "Unpause", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}], "name": "OwnershipRenounced", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}, {"indexed": true, "name": "newOwner", "type": "address"}], "name": "OwnershipTransferred", "type": "event"}], "userdoc": {"methods": {"renounceOwnership()": {"notice": "Renouncing to ownership will leave the contract without an owner. It will not be possible to call the functions with the `onlyOwner` modifier anymore."}}}}, "endpoint": {}, "dev": {"devdoc": {"methods": {"pause()": {"details": "called by the owner to pause, triggers stopped state"}, "renounceOwnership()": {"details": "Allows the current owner to relinquish control of the contract."}, "transferOwnership(address)": {"details": "Allows the current owner to transfer control of the contract to a newOwner."}, "unpause()": {"details": "called by the owner to unpause, returns to normal state"}}, "title": "Pausable"}, "sources": {"keccak256": "0x84c7090c27cf3657b73d9e26b6b316975fa0bd233b8169f254de0c3b3acfaefc", "swarm_URL": "bzzr://b983355647976c1daa5de581a1b6a41be9c5adc17cce257b8679649db78f8a11"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.23;\n\n\nimport \"./Ownable.sol\";\n\n\n/**\n * @title Pausable\n * @dev Base contract which allows children to implement an emergency stop mechanism.\n */\ncontract Pausable is Ownable {\n  event Pause();\n  event Unpause();\n\n  bool public paused = false;\n\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is not paused.\n   */\n  modifier whenNotPaused() {\n    require(!paused);\n    _;\n  }\n\n  /**\n   * @dev Modifier to make a function callable only when the contract is paused.\n   */\n  modifier whenPaused() {\n    require(paused);\n    _;\n  }\n\n  /**\n   * @dev called by the owner to pause, triggers stopped state\n   */\n  function pause() onlyOwner whenNotPaused public {\n    paused = true;\n    emit Pause();\n  }\n\n  /**\n   * @dev called by the owner to unpause, returns to normal state\n   */\n  function unpause() onlyOwner whenPaused public {\n    paused = false;\n    emit Unpause();\n  }\n}\n"}, {"name": "MyLib", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "MyLib", "author": "Gav Wouldn't", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [{"name": "amount", "type": "uint256"}, {"name": "conversionRate", "type": "uint256"}], "name": "convert", "outputs": [{"name": "convertedAmount", "type": "uint256"}], "payable": false, "stateMutability": "nonpayable", "type": "function"}], "userdoc": {"methods": {"convert(uint256,uint256)": {"notice": "Converts given value to Ether value"}}}}, "endpoint": {}, "dev": {"devdoc": {"author": "Gav Wouldn't", "methods": {"convert(uint256,uint256)": {"return": "{ \"convertedAmount\" : \"Ether equivalent amount\" }"}}, "title": "Some Other Library"}, "sources": {"keccak256": "0xbe468f4d111cd6cb5690a89fbc45b6716f809a26e0b96c305d734ec91516ff6a", "swarm_URL": "bzzr://aa8420283df9f1626eb1cc26f03f0a262ac890a51fbb673e4642adb60c47b8b5"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.2;\n\n/**\n@title Some Other Library\n@author Gav Wouldn't\n*/\nlibrary MyLib{\n\t/**\n\t@notice Converts given value to Ether value\n\t@param amount Token amount\n\t@param conversionRate Rate of conversion - Tokens -> Ether\n\t@return { \"convertedAmount\" : \"Ether equivalent amount\" }\n\t*/\n\tfunction convert(uint amount, uint conversionRate) returns (uint convertedAmount)\n\t{\n\t\treturn amount * conversionRate;\n\t}\n}\n"}, {"name": "Ownable", "contract_type": "generic_contract", "JSON": {"contract": {"descriptor": {"name": "Ownable", "author": "", "language": "Solidity", "contract_type": "generic_contract", "contract_version": "1.0", "descriptor_version": "1.0", "abi": [{"constant": false, "inputs": [], "name": "renounceOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"constant": true, "inputs": [], "name": "owner", "outputs": [{"name": "", "type": "address"}], "payable": false, "stateMutability": "view", "type": "function"}, {"constant": false, "inputs": [{"name": "_newOwner", "type": "address"}], "name": "transferOwnership", "outputs": [], "payable": false, "stateMutability": "nonpayable", "type": "function"}, {"inputs": [], "payable": false, "stateMutability": "nonpayable", "type": "constructor"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}], "name": "OwnershipRenounced", "type": "event"}, {"anonymous": false, "inputs": [{"indexed": true, "name": "previousOwner", "type": "address"}, {"indexed": true, "name": "newOwner", "type": "address"}], "name": "OwnershipTransferred", "type": "event"}], "userdoc": {"methods": {"renounceOwnership()": {"notice": "Renouncing to ownership will leave the contract without an owner. It will not be possible to call the functions with the `onlyOwner` modifier anymore."}}}}, "endpoint": {}, "dev": {"devdoc": {"methods": {"renounceOwnership()": {"details": "Allows the current owner to relinquish control of the contract."}, "transferOwnership(address)": {"details": "Allows the current owner to transfer control of the contract to a newOwner."}}, "title": "Ownable"}, "sources": {"keccak256": "0x84c7090c27cf3657b73d9e26b6b316975fa0bd233b8169f254de0c3b3acfaefc", "swarm_URL": "bzzr://b983355647976c1daa5de581a1b6a41be9c5adc17cce257b8679649db78f8a11"}, "libraries": {}, "compiler": {"version": "0.4.24+commit.e67f0147", "evmVersion": "byzantium"}}}}, "code": "pragma solidity ^0.4.24;\n\n\n/**\n * @title Ownable\n * @dev The Ownable contract has an owner address, and provides basic authorization control\n * functions, this simplifies the implementation of \"user permissions\".\n */\ncontract Ownable {\n  address public owner;\n\n\n  event OwnershipRenounced(address indexed previousOwner);\n  event OwnershipTransferred(\n    address indexed previousOwner,\n    address indexed newOwner\n  );\n\n\n  /**\n   * @dev The Ownable constructor sets the original `owner` of the contract to the sender\n   * account.\n   */\n  constructor() public {\n    owner = msg.sender;\n  }\n\n  /**\n   * @dev Throws if called by any account other than the owner.\n   */\n  modifier onlyOwner() {\n    require(msg.sender == owner);\n    _;\n  }\n\n  /**\n   * @dev Allows the current owner to relinquish control of the contract.\n   * @notice Renouncing to ownership will leave the contract without an owner.\n   * It will not be possible to call the functions with the `onlyOwner`\n   * modifier anymore.\n   */\n  function renounceOwnership() public onlyOwner {\n    emit OwnershipRenounced(owner);\n    owner = address(0);\n  }\n\n  /**\n   * @dev Allows the current owner to transfer control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function transferOwnership(address _newOwner) public onlyOwner {\n    _transferOwnership(_newOwner);\n  }\n\n  /**\n   * @dev Transfers control of the contract to a newOwner.\n   * @param _newOwner The address to transfer ownership to.\n   */\n  function _transferOwnership(address _newOwner) internal {\n    require(_newOwner != address(0));\n    emit OwnershipTransferred(owner, _newOwner);\n    owner = _newOwner;\n  }\n}\n"}]}